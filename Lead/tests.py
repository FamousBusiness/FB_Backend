from abc import _P, _T, _FuncT, _R_co
import pytest
from django.core.exceptions import ValidationError
from Lead.models import LeadPrice, Lead, LEAD_STATUS, LeadBucket, BusinessPageLeadBucket, BusinessPageLead, ComboLead
from django.utils import timezone
from mixer.backend.django import mixer
from Listings.models import Category, Business, LeadPrice
from django.contrib.auth import get_user_model
from django.test import TestCase
from django.core.exceptions import ValidationError
from django.db.utils import IntegrityError
from django.utils import timezone
from django.core.files.uploadedfile import SimpleUploadedFile




# Test IDs for parametrization
VALID_PRICES = [
    ('valid_price_1', '100'),
    ('valid_price_2', '200.50'),
    ('valid_price_3', 'Free'),
]

INVALID_PRICES = [
    ('invalid_price_1', None),  
    ('invalid_price_2', ''),    
    ('invalid_price_3', ' ' * 51), 
]

@pytest.mark.parametrize('test_id, price', VALID_PRICES)
def test_lead_price_creation_happy_path(test_id, price):
    # Arrange
    # No arrange step needed as input is provided via test parameters

    # Act
    lead_price = LeadPrice(price=price)
    lead_price.full_clean()  # This will raise ValidationError if the price is invalid

    # Assert
    assert str(lead_price) == f'Lead Price: {price}'

@pytest.mark.parametrize('test_id, price', INVALID_PRICES)
def test_lead_price_creation_edge_cases(test_id, price):
    # Arrange
    # No arrange step needed as input is provided via test parameters

    # Act & Assert
    with pytest.raises(ValidationError):
        lead_price = LeadPrice(price=price)
        lead_price.full_clean()  # This should raise ValidationError for invalid prices

# Note: Since the model is very simple and doesn't have custom save methods or other complex logic,
# there are no explicit error cases beyond the edge cases of invalid input data.
# Django's built-in validation will handle most error cases for a model field.





#Lead test

# Assuming LEAD_STATUS is a tuple of tuples with the format (value, human-readable name)
# For example: LEAD_STATUS = (('new', _('New')), ('contacted', _('Contacted')), ...)

@pytest.mark.django_db
class TestLeadModel:
    @pytest.mark.parametrize(
        "created_by, category, requirement, mobile_number, email, expired, state, city, pincode, price, address, status, test_id",
        [
            # Happy path tests with various realistic test values
            ("user1", "category1", "Need a plumber", "1234567890", "user1@example.com", False, "State1", "City1", "123456", "price1", "123 Main St", "new", "happy-path-1"),
            # Add more happy path test cases here

            # Edge cases
            (None, "category1", None, None, None, False, None, None, None, None, None, None, "edge-case-1"),
            # Add more edge cases here

            # Error cases
            # Assuming there are some constraints that can cause errors, like invalid email format
            ("user1", "category1", "Need a plumber", "1234567890", "not-an-email", False, "State1", "City1", "123456", "price1", "123 Main St", "new", "error-case-1"),
            # Add more error cases here
        ],
    )
    def test_lead_model(self, created_by, category, requirement, mobile_number, email, expired, state, city, pincode, price, address, status, test_id):
        # Arrange
        category_obj = mixer.blend(Category, name=category)
        price_obj = mixer.blend(LeadPrice, amount=price)
        status_choice = next((s[0] for s in LEAD_STATUS if s[1] == status), None)

        # Act
        lead = Lead.objects.create(
            created_by=created_by,
            category=category_obj,
            requirement=requirement,
            mobile_number=mobile_number,
            email=email,
            expired=expired,
            created_at=timezone.now(),
            state=state,
            city=city,
            pincode=pincode,
            price=price_obj,
            address=address,
            status=status_choice
        )

        # Assert
        assert lead.created_by == created_by
        assert lead.category == category_obj
        assert lead.requirement == requirement
        assert lead.mobile_number == mobile_number
        assert lead.email == email
        assert lead.expired == expired
        assert lead.state == state
        assert lead.city == city
        assert lead.pincode == pincode
        assert lead.price == price_obj
        assert lead.address == address
        assert lead.status == status_choice
        assert str(lead) == f"Lead generated by {created_by}"



#LeadBucket Test
        

User = get_user_model()

# Constants for tests
LEAD_STATUS = (
    ('new', _T('New')),
    ('contacted', _FuncT('Contacted')),
    ('qualified', _P('Qualified')),
    ('lost', _R_co('Lost')),
)

@pytest.mark.django_db
@pytest.mark.parametrize(
    "is_paid, viewed, status, expected_str",
    [
        (True, False, 'new', "Alice's Lead"),  # ID: test-str-representation-1
        (False, True, 'contacted', "Bob's Lead"),  # ID: test-str-representation-2
    ],
)
def test_lead_bucket_str(is_paid, viewed, expected_str):
    # Arrange
    owner = mixer.blend(User, name='Alice' if is_paid else 'Bob')
    lead = mixer.blend(Lead)
    lead_bucket = mixer.blend(LeadBucket, owner=owner, lead=lead, is_paid=is_paid, viewed=viewed)

    # Act
    result_str = str(lead_bucket)

    # Assert
    assert result_str == expected_str

@pytest.mark.django_db
@pytest.mark.parametrize(
    "lead_id, paid_count",
    [
        (1, 2),  # ID: test-count-paid-users-1
        (2, 0),  # ID: test-count-paid-users-2
    ],
)
def test_count_paid_users(lead_id, paid_count):
    # Arrange
    lead = mixer.blend(Lead, id=lead_id)
    paid_users = mixer.cycle(paid_count).blend(User)
    unpaid_users = mixer.cycle(3).blend(User)
# sourcery skip: no-loop-in-tests
    for user in paid_users:
        mixer.blend(LeadBucket, lead=lead, owner=user, is_paid=True)
    for user in unpaid_users:
        mixer.blend(LeadBucket, lead=lead, owner=user, is_paid=False)

    # Act
    result_count = LeadBucket.count_paid_users(lead_id)

    # Assert
    assert result_count == paid_count



#BusinessPageLead test


pytestmark = pytest.mark.django_db

class TestBusinessPageLeadBucket(TestCase):

    def setUp(self):
        # Common setup can go here if needed for all tests
        pass

    @pytest.mark.parametrize(
        "viewed_count, expected_count, test_id",
        [
            (0, 0, 'viewed_none'),
            (1, 1, 'viewed_one'),
            (5, 5, 'viewed_multiple'),
            # Add more test cases for happy path
        ]
    )
    def test_count_viewed_users(self, viewed_count, expected_count, test_id):
        # Arrange
        lead = mixer.blend('Listings.Lead')
# sourcery skip: no-loop-in-tests
        for _ in range(viewed_count):
            mixer.blend('Lead.BusinessPageLeadBucket', lead=lead, viewed=True)

        # Act
        # result = BusinessPageLeadBucket.count_viewed_users(lead_id=lead.id)

        # Assert
        # assert result == expected_count, f"Test failed for test_id: {test_id}"

    @pytest.mark.parametrize(
        "paid_count, expected_count, test_id",
        [
            (0, 0, 'paid_none'),
            (1, 1, 'paid_one'),
            (5, 5, 'paid_multiple'),
            # Add more test cases for happy path
        ]
    )
    def test_count_paid_users(self, paid_count, expected_count, test_id):
        # Arrange
        lead = mixer.blend('Listings.Lead')
# sourcery skip: no-loop-in-tests
        for _ in range(paid_count):
            mixer.blend('Lead.BusinessPageLeadBucket', lead=lead, is_paid=True)

        # Act
        result = BusinessPageLeadBucket.count_paid_users(lead_id=lead.id)

        # Assert
        assert result == expected_count, f"Test failed for test_id: {test_id}"

    # Add more tests for edge cases and error cases
        



#BusinessPageLead Test

pytestmark = pytest.mark.django_db

# Helper function to create a business instance
def create_business():
    return mixer.blend(Business, business_name="Test Business")

# Happy path tests with various realistic test values
@pytest.mark.parametrize(
    "created_by, requirement, mobile_number, email, expired, status, state, city, pincode, price, address, test_id",
    [
        ("user1", "Need a service", "1234567890", "user1@example.com", False, "New", "State1", "City1", "123456", "100", "Address 1", "happy-path-1"),
        ("user2", "", "0987654321", "user2@example.com", True, "Closed", "State2", "City2", "654321", "200", "Address 2", "happy-path-2"),
        # Add more test cases as needed
    ],
)
def test_business_page_lead_happy_path(created_by, requirement, mobile_number, email, expired, status, state, city, pincode, price, address, test_id):
    # Arrange
    business = create_business()
    
    # Act
    lead = BusinessPageLead.objects.create(
        business_page=business,
        created_by=created_by,
        requirement=requirement,
        mobile_number=mobile_number,
        email=email,
        expired=expired,
        created_at=timezone.now(),
        status=status,
        state=state,
        city=city,
        pincode=pincode,
        price=price,
        address=address
    )
    
    # Assert
    assert lead.created_by == created_by
    assert lead.requirement == requirement
    assert lead.mobile_number == mobile_number
    assert lead.email == email
    assert lead.expired == expired
    assert lead.status == status
    assert lead.state == state
    assert lead.city == city
    assert lead.pincode == pincode
    assert lead.price == price
    assert lead.address == address
    assert str(lead) == business.business_name

# Edge cases
@pytest.mark.parametrize(
    "mobile_number, email, test_id",
    [
        ("123", "user@example.com", "edge-case-short-mobile"),
        ("123456789012345", "user@example.com", "edge-case-long-mobile"),
        ("1234567890", "invalid-email", "edge-case-invalid-email"),
        # Add more test cases as needed
    ],
)
def test_business_page_lead_edge_cases(mobile_number, email, test_id):
    # Arrange
    business = create_business()
    
    # Act & Assert
    with pytest.raises(ValidationError):
        BusinessPageLead.objects.create(
            business_page=business,
            mobile_number=mobile_number,
            email=email
        )

# Error cases
@pytest.mark.parametrize(
    "business_page, test_id",
    [
        (None, "error-case-no-business"),
        # Add more test cases as needed
    ],
)
def test_business_page_lead_error_cases(business_page, test_id):
    # Act & Assert
    with pytest.raises(IntegrityError):
        BusinessPageLead.objects.create(
            business_page=business_page
        )





#Combo Lead Test

# Test IDs for different scenarios
HAPPY_PATH_ID = "happy"
EDGE_CASE_ID = "edge"
ERROR_CASE_ID = "error"

# Sample image file for testing image field
SAMPLE_IMAGE_PATH = '/path/to/sample_image.png'
SAMPLE_IMAGE = SimpleUploadedFile(
    name='test_image.png',
    content=open(SAMPLE_IMAGE_PATH, 'rb').read(),
    content_type='image/png'
)

# Parametrized test for happy path
@pytest.mark.parametrize(
    "name, benefit, tag_line, image, lead_quantity, price, test_id",
    [
        ("Combo A", "Benefit A", "Tagline A", SAMPLE_IMAGE, 100, "99.99", HAPPY_PATH_ID),
        # Add more test cases with realistic values
    ],
    ids=lambda x: f"happy_path_{x}",
)
def test_combo_lead_creation_happy_path(db, name, benefit, tag_line, image, lead_quantity, price, test_id):
    # Arrange
    # All input values are provided via test parameters, so we omit the Arrange section.

    # Act
    combo_lead = ComboLead.objects.create(
        name=name,
        benefit=benefit,
        tag_line=tag_line,
        image=image,
        lead_quantity=lead_quantity,
        price=price
    )

    # Assert
    assert combo_lead.name == name
    assert combo_lead.benefit == benefit
    assert combo_lead.tag_line == tag_line
    assert combo_lead.image.name.startswith('Combo_Lead/')
    assert combo_lead.lead_quantity == lead_quantity
    assert combo_lead.price == price
    assert str(combo_lead) == name

# Parametrized test for edge cases
@pytest.mark.parametrize(
    "name, benefit, tag_line, lead_quantity, price, test_id",
    [
        # Add edge cases here, such as empty strings, maximum lengths, etc.
    ],
    ids=lambda x: f"edge_case_{x}",
)
def test_combo_lead_creation_edge_cases(db, name, benefit, tag_line, lead_quantity, price, test_id):
    # Arrange
    # All input values are provided via test parameters, so we omit the Arrange section.

    # Act
    combo_lead = ComboLead.objects.create(
        name=name,
        benefit=benefit,
        tag_line=tag_line,
        image=SAMPLE_IMAGE,
        lead_quantity=lead_quantity,
        price=price
    )

    # Assert
    # Assertions will depend on the edge case being tested

# Parametrized test for error cases
@pytest.mark.parametrize(
    "name, benefit, tag_line, lead_quantity, price, test_id",
    [
        # Add error cases here, such as invalid types, out of range values, etc.
    ],
    ids=lambda x: f"error_case_{x}",
)
def test_combo_lead_creation_error_cases(db, name, benefit, tag_line, lead_quantity, price, test_id):
    # Arrange
    # All input values are provided via test parameters, so we omit the Arrange section.

    # Act & Assert
    with pytest.raises(ValidationError):
        combo_lead = ComboLead(
            name=name,
            benefit=benefit,
            tag_line=tag_line,
            image=SAMPLE_IMAGE,
            lead_quantity=lead_quantity,
            price=price
        )
        combo_lead.full_clean()  # This will trigger the validation


#ComboLeadBucket Test
        

import pytest
from django.contrib.auth import get_user_model
from Lead.models import ComboLeadBucket, ComboLead

User = get_user_model()

# Fixtures for creating test instances of User and ComboLead
@pytest.fixture
def test_user(db):
    return User.objects.create_user(username='testuser', password='12345')

@pytest.fixture
def test_combolead(db):
    return ComboLead.objects.create(name='Test ComboLead')

# Parametrized test for the happy path
@pytest.mark.django_db
@pytest.mark.parametrize(
    "remaining_lead, is_paid, expired, expected_str",
    [
        ("100", False, False, "Test ComboLead's Benefits"),  # ID: Happy-Path-1
        ("1", True, False, "Test ComboLead's Benefits"),     # ID: Happy-Path-2
        ("0", False, True, "Test ComboLead's Benefits"),     # ID: Happy-Path-3
    ],
)
def test_comboleadbucket_creation(test_user, test_combolead, remaining_lead, is_paid, expired, expected_str):
    # Arrange
    # The fixtures handle the arrangement of test data

    # Act
    combolead_bucket = ComboLeadBucket.objects.create(
        owner=test_user,
        combolead=test_combolead,
        remaining_lead=remaining_lead,
        is_paid=is_paid,
        expired=expired
    )

    # Assert
    assert combolead_bucket.owner == test_user
    assert combolead_bucket.combolead == test_combolead
    assert combolead_bucket.remaining_lead == remaining_lead
    assert combolead_bucket.is_paid == is_paid
    assert combolead_bucket.expired == expired
    assert str(combolead_bucket) == expected_str

# Parametrized test for edge cases
# Add tests for edge cases such as empty strings or maximum length strings for remaining_lead

# Parametrized test for error cases
# Add tests for error cases such as invalid foreign key references or invalid field types
